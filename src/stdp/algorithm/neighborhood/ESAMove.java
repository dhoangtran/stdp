package dsbp.algorithm.neighborhood;

import java.util.*;

import dsbp.model.*;

/**
 * This class represents a Shift Move (as in the paper). A neighbor in the Shift
 * Move is generated by re-scheduling one job from the machine with the largest
 * total execution time (or a random machine) to another position in the
 * machine. The parameter "useMakespanMachine" determines whether the machine
 * with the largest total execution time is always used.
 *
 * @author Hoang Tran
 */
public class ESAMove extends Move {

	public int position;
	public int alpha;
	double initialBalancingCost;
	double initialDrivingCost;
	double[] timeBalancingCosts;
	int[][] supplies;
	double[][] demandSupplyRatio;
	
	/**
     * Instantiates a new Shift Move.
     *
     * @param problem            problem.
     * @param random             random number generator.
     * @param priority           the priority of this neighborhood.
     * @param useMakespanMachine true if the makespan machine should be always
     *                           considered or false otherwise.
     */
    public ESAMove(Problem problem, Random random, int priority) {
        super(problem, random, "Increasing", priority);
        
        timeBalancingCosts = new double[problem.nRegions];
    	supplies = new int[problem.nTimeHorizons][problem.nRegions];
    	demandSupplyRatio = new double[problem.nTimeHorizons][problem.nRegions];
    }

    public void accept() {
        super.accept();
    }

    public double doMove(Solution solution, int[] STPMST) {
        super.doMove(solution);
        initialBalancingCost = solution.balancingCost;
        initialDrivingCost = solution.drivingCost;
        System.arraycopy(solution.timeBalancingCosts, 0, timeBalancingCosts, 0, solution.timeBalancingCosts.length);
        for (int k = 0; k < problem.nTimeHorizons; k++) {
        	System.arraycopy(solution.supplies[k], 0, supplies[k], 0, problem.nRegions);
        	System.arraycopy(solution.demandSupplyRatio[k], 0, demandSupplyRatio[k], 0, problem.nRegions);
        }
		
		do {
			position = random.nextInt(solution.size);
			//int num = (int) Math.round(random.nextDouble() * STPMST[position]) + 1;
			int num = random.nextInt(3) + 1;
			alpha = random.nextInt(2)==0 ? num : -num;
		} while (!solution.validate(position, alpha));
		solution.dispatch[position] += alpha;
		solution.updateTotalCost(position, alpha);
		return deltaCost = solution.getTotalCost() - initialCost;
    }

    public boolean hasMove(Solution solution) {
        //return solution.validate();
    	return true;
    }

    public void reject() {
        super.reject();
        
        currentSolution.dispatch[position] -= alpha;
        currentSolution.balancingCost = initialBalancingCost;
        currentSolution.drivingCost = initialDrivingCost;
        currentSolution.totalCost = initialCost;
        System.arraycopy(timeBalancingCosts, 0, currentSolution.timeBalancingCosts, 0, currentSolution.timeBalancingCosts.length);
        for (int k = 0; k < problem.nTimeHorizons; k++) {
        	System.arraycopy(supplies[k], 0, currentSolution.supplies[k], 0, currentSolution.problem.nRegions);
        	System.arraycopy(demandSupplyRatio[k], 0, currentSolution.demandSupplyRatio[k], 0, currentSolution.problem.nRegions);
        }
        //currentSolution.updateTotalCost(position, -alpha);
        //currentSolution.updateTotalCost();
    }
}
